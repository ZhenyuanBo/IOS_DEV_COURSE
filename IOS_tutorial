1. 'Single View App' is not available in Xcode12 any more, choose 'App' instead
2. interface builder - press control and connect the image to point where we want to define the 
IBOutlet
3. Button Type - "Touch Up Inside": user's finger is positioned within the boundary of the Button
4. String concatenation:
let a = "Hello"
let b = "World"

let first = a + ", " + b
let second = "\(a), \(b)"

You could also do:

var c = "Hello"
c += ", World"

5. if a variable's value is not mutated, we can use 'let' instead; let keywords set a constant value
6. double can hold more decimals than float
7. range operator
    1). inclusive range operator: Int.random(in: lower ... upper)
    2). exclude upper: Int.random(in: lower ..< upper)

8. add constraint and alignment
9. Autolayout
    1. group views into stack views
    2. add constraints to it (relative to safe area)
    3. alignment - set to fill
    4. distribution - set to fill equally
    5. spacing set to 1 
    6. we can also set superview to bottom

10. function signature

func myFunction(parameter: DataType){

}

11. var myAge: Int = 3
    var myAge: String = "Three"

12 optional

var hardness: String? - optional DataType
it can store a string or can be Nil (empty data)

var player1Username: String = nil 
this gives an error because variable expects a string value

correction:

var player1Username: String? = nil

player1Username = "jackbauerisawesome"

print(player1Username) ---> Optional("jackbauerisawesome")

to remove Optional, we can add "!"

when we get a value out from a dictionary using the key, the value is optional. we need to unwrap it if it is not a null value

13. MVC - Model View Controller

14. external/internal parameter

    func checkAnswer(answer userAnswer: String){
        let actualAnswer = quiz[questionNumber].answer
    }

    answer ->> external
    userAnswer ->> internal

OR: we do not need to define external parameter name

func checkAnswer(_ userAnswer: String){}


func myFunc(exname eman: Type){
    print(eman)
}

when calling function:

we can do myFunc(exname: val)

or we can do

myFunc(val) ---> but, this needs exname changed to '_'

so func signature will be:

func myFunc(_ eman: Type){
    
}

15. struct is immutable

Note: for the variables defined using 'var' keyword, if we mutate the value within the struct itself, an error of immutability will be thrown out; however, if we mutate the value outside of the struct, we will be allowed to do so.

16. when self is created from the background, all the properties created are actually defined using 'let' keyword. Thus, self iself 
is immutable

17. mutating function can only be called by a mutable object, which is defined using 'var' keyword. If this object is defined using 'let' keyword, mutating function can't be invoked by a immutable object (defined using 'let')

18. struct vs. class

let skeleton2 = skeleton1 this is copied by reference
both skeleton2 and skeleton1 are pointing to the same object

struct: create another copy so that it is separated from the original object

structs are passed by value 
classes are passed by reference

19. use struct by default

when you need inheritance, you can use class

struct: immutable

class: passed by reference, can inherit from other classes

20. use segue to connect from controller view to another view

we use cocoa touch class to create controller class - set subclass UIViewController


21. Working with Optional

1. Force Unwrapping

we need to really think if the value could be a nil value when we wrap it, if it is a nil value and we unwrap it, an error will probably occur


2. check for nil value

if optional != nil {
    optional!
}

3. optional binding

if let safeOptional = optional{
    safeOptional
}

we can bind the value of optional to the new safeOptional if it is not a nil value
and we can work with the safeOptional

example:

let myOptional: String?

myOptional = "Angela"

if let safeOptional = myOptional{
    let text: String = safeOptional
    print(safeOptional)
}else{
    print("myOptional was found to be nil")
}

if myOptional is a nil value, then else clause will be executed; otherwise, 
if clause will be executed if it is a non-nil value

4. Nil Coalescing operator

optional ?? defaultValue

let myOptional: String?

myOptional = nil

let text: String = myOptional ?? "I am the default" 

if it is a nil value, then the default value will be assigned to text


5. Optional chaining

optional?.property ---> if optional is not a nil, then we can access the property
optional?,method() ----> if optional is not a nil, then we can access the method


struct MyOptional{
    var property = 123

    func method(){
        print("I am the struct's method.")
    }
}

let myOptional: MyOptional?

myOptional = nil

print(myOptional?.property)  

myOptional = MyOptional()

print(myOptional?.method()) ----> since myOptional is not a nil value, method will be triggered


22. add color asset
1). click on Assets.xcasset 
2). click on '+' Button
3). set any appearance color to the color selected using the color picker

23. change the background image based on the user's Model

using vector image:
1). drag pdf image to assets.xcassets and set it to 1x background
2). check preserve vector on the right side menu
3). select single scale for the scales


24. Protocols

protocol MyProtocol{
    //define requirements; consider protocol like a certification
}

adopting the protocol
struct MyStruct: MyProtocol{}

class MyClass: MyProtocol{}

class Bird{
    var is Female = true

    func layEgg(){
        if isFemale{
            print("The bird makes a new bird in a shell.")
        }
    }
    func fly(){
        print("The bird flaps its wings and lifts off into the sky.")
    }
}

class Eagle: Bird{


    func soar(){
        print("The eagle glides in the air using air curents.")
    }
}

let myEagle = Eagle()
myEagle.fly()
myEagle.layEgg()
myEagle.soar()


class Penguin: Bird{
    func swim(){
        print("The penguin paddles through the water.")
    }
}


let myPenguin = Penguin()
myPenguin.layEgg()
myPenGuin.swim()
myPenguin.fly() // penguin actually can't fly -- problem

**********************************************************************
we don't want penguin inherit some functionality that they should have
**********************************************************************

struct FlyMuseum{
    func flyingDemo(FlyingObject: Bird){
        flyingObject.fly()
    }
}

let museum = FlyMuseum()
museum.flyingDemo(flyingObject: myEagle)
museum.flyingDemo(flyingObject: myPenguin) // this is not intended behavior

class Airplane: Bird{
    override func fly(){
        print("The airplane uses its engine to lift off into the air.")
    }
}

let myPlane = Airplane()
myPlane.layEgg() ----> doesn't make any sense

struct can't inherit!!!


//every one has the capability to fly

protocol CanFly{
    func fly() ---> protocol methods must not have bodies
}

class Eagle: Bird, CanFly{
    func soar(){

    }
    

    //implement the fly method
    func fly(){
        print("The bird flaps its wings and lifts off into the sky.")
    }
}

Penguin can't fly, so it doesn't need to implement fly() method

//protocols can be adopted by struct or class
struct Airplane: CanFly{
    func fly(){
        print("The airplen uses its engine to lift off into the air.")
    }
}

struct FlyingMusuem{
    //can use protocol as the data type
    //all the objects that adopt this protocol must have fly() method
    func flyingDemo(flyingObject: CanFly){
        flyingObject.fly()
    }
}

myEagle.fly()
myPlane.fly()

musuem.flyingDemo(flyingObject: myPlane)
musuem.flyingDemo(flyingObject: myEagle)
//can't do this:
musuem.flyingDemo(flyingObject: myPenguin)

you can adopt multiple protocols

struct MyStructure: FirstProtcol, SecondProtocol{

}

class MyClass: SuperClass, FirstProcol, AnotherProtcol{

}


25. Delegate Design Pattern


1). we need text field to notify the WeatherViewController when the 
editing activity takes place
2). UITextField can't know the identity of future classes --> this comes the Delegate
design Pattern

in order for a class to have the type UITextFieldDelegate, the class has to adopt it

3). let textField = UITextField()

textField.delegate = self //assign textField's delegate to the class itself

whenever a change is made to the text field, this delegate will be notified, which means 

class will be notified

sequence of events:

1). create textField  let textField = UITextField()
2). textField.delegate = self

in UITextField

var delegate: UITextFieldDelegate 

so, delegate is now pointing to self, which is pointing to the WeatherViewController
we can do this because WeatherViewController adopts UITextFieldDelegate

3). if textfield detecs user's activity, it will trigger: delegate.textFieldDidBeginEditing()

which indirectly triggers textFieldDidBeginEditing defined in the WeatherViewController


26 Example:

protocol AdvancedLifeSupport{
    func performCPR()
}

class EmergencyCallHandler{
    var delegate: AdvancedLifeSupport?

    func assessSituation(){

    }

    func medicalEmergency(){
        delegate?.performCPR()
    }
}


struct Paramedic: AdvancedLifeSupport{

    init(handler: EmergencyCallHandler){
        handler.delegate = self
    }

    func performCPR(){
        print("The paramedic does chest compressions, 30 per second.")
    }
}


let emillio = EmergencyCallHandler()
let pete = Paramedic(handler: emilio)

emilio.assessSituation()

emilio.medicalEmergency() ---> pete.performCPR() will be triggered 

Example 2:

class Doctor: AdvancedLifeSupport{
    init(handler: EmergencyCallHandler){
        handler.delegate = self
    }

    func performCPR(){
        print("The doctor does chest compressions, 30 per second.")
    }

    func useStethescope(){
        print("Listening for heard sounds")
    }
}

//automatically adopt AdvancedLifeSupport protocol
class Surgeon: Doctor{
    override func performCPR(){
        super.performCPR()
        print()
    }

    func useElectricDrill(){

    }
}

let angela = Surgeon(handler: emilio)


28. common networking error: the resource could not be loaded because the App Transport
Security policy requires the use of a secure connection

resolution: http---> https


29. closures

pass function as an input

func calculator(n1: Int, n2: Int)->Int{
    return n1*n2
}

func add(no1: Int, no2: Int)->Int{
    return n1+n2
}

func calculator(n1: Int, n2: Int, operation: (Int, Int)->Int)->Int{
    return operation(n1, n2)
}

calculator(n1: 2, n2: 3, operation: add)

//add function is parsed as an argument

closures
calculator(n1: 2, n2: 3, operation: {(no1, no2) in no1*no2})

OR

calculator(n1: 2, n2: 3, operation: {$0 * $1})

OR 

trailing closure: 

calculator(n1: 2, n2: 3) {$0 * $1}


let array = [6, 2, 3, 9, 4, 1]

func addOne(n1: Int)->Int{
    return n1+1
}

{(n1)->in n1+1}

array.map(addOne)

array.map({(n1)->in n1+1})

==

array.map({$0+1})

==

array.map{$0+1}

Another example:

array.map{"\($0)"}


30. computed property

var aProperty: Int{
    //have to provide an output

    return 2+5 // this is computation
}

31 codable --> type alias for Decoddable & Encodable



